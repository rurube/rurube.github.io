---
title: 머신 러닝의 기본 요소
category: AI
tags:
  - [DL, 케창딥]
date: 2023-07-31
math: true
---

## 5.1 일반화: 머신 러닝의 목표

- 최적화(optimization): 가능한 훈련 데이터에서 최고의 성능을 얻기 위해 모델을 조정하는 과정
- 일반화(generalization): 훈련된 모델이 새로운 데이터에서 얼마나 잘 수행되는지 의미
- 머신 러닝의 목표는 **좋은 일반화 성능**을 얻는 것



### 5.1.1 과소적합과 과대적합

- 과소적합
  - 훈련 초기에 훈련 손실이 낮아질수록 검증 손실이 함께 낮아지는 구간
  - 모델 성능이 발전될 여지가 있음
  - 훈련 데이터에 있는 패턴을 모두 학습하지 못함
- 과대적합
  - 훈련을 일정 이상 반복한 후 검증 세트의 성능이 멈추고 감소되기 시작하는 구간
  - 훈련 데이터에 **특화된** 패턴을 학습하기 시작함
  - 데이터에 **잡음**이 있거나, **불확실성**이 존재하거나, **드문 특성**이 포함되어 있을 때 발생하기 쉬움
    - 잡음 섞인 훈련 데이터: 잘못된 입력, 잘못된 레이블
    - 불확실한 특성: 범주에 객관적 경계가 없는 **모호성**, 같은 데이터에 다른 결과가 따를 수 있는 **무작위성**
    - 드문 특성과 가짜 상관관계: 특성이 드물면 모델이 특성을 잘못 판단할 수 있고, 잘못된 추측으로 인해 실제로는 관련이 없는 가짜 상관관계가 생길 수도 있다.
  - 잡음 제거를 위해 특성 선택(feature selection)을 진행할 수 있음



### 5.1.2 딥러닝에서 일반화의 본질

- 매니폴드 가설
  - 매니폴드란 선형 공간과 비슷하게 보이는 부모 공간의 저차원 부분 공간이다.
  - **매니폴드 가설(manifold hypothesis)**은 실제 세상의 모든 데이터가 고차원 공간 안에 있는 저차원 매니폴드에 놓여 있다고 가정한다
  - 매니폴드 가설은 다음을 의미한다
    - 머신 러닝 모델은 입력 공간 안에서 비교적 간단하고, 저차원이며, 매우 구조적인 부분 공간(잠재 매니폴드(latent manifold))만 학습하면 된다
    - 이런 매니폴드 중 하나 안에서 두 입력 사이를 보간(interpolation)하는 것이 항상 가능하다. 즉, 연속적인 경로를 따라 한 입력에서 다른 입력으로 변형할 때 모든 포인트가 매니폴드에 속한다.
- 일반화의 원천인 보간
  - 다루는 데이터 포인트가 보간 가능하다면 새로운 포인트를 해당 매니폴드에서 가까이 놓인 다른 포인트와 연결하여 이해할 수 있다
  - 보간을 사용해 빈 곳을 채움으로써 공간 안의 샘플만으로 공간 전체를 이해할 수 있다
  - 지역 일반화(local generalizaion): 이전에 본 것과 매우 가까운 것을 이해하는 것
  - 궁극 일반화(extreme generalization): 사람이 일반화하는 방법으로, 보간 이외의 인지 매커니즘을 사용한다. 인지 매커니즘은 추상화, 세상에 대한 상징적 모델, 추론, 논리, 상식, 이성으로 불리는 세상에 대한 선천적 능력 등을 말한다.
- 딥러닝이 작동하는 이유
  - 데이터를 구겨진 종이 공으로 비유하면, 펴진 종이는 2D 매니폴드를 나타내고 딥러닝은 구겨진 종이 공을 펼치는 도구이다
  - 딥러닝은 근본적으로 미분 가능한 곡선으로 경사 하강법을 통해 이 곡선을 데이터 포인트에 맞춘다
    - 크고 복잡한 곡선(매니폴드)을 선택하여 훈련 데이터 포인트에 맞을 때까지 파라미터를 점진적으로 조정한다
    - 데이터는 입력 공간 안에서 고도로 구조적인 저차원 매니폴드를 형성(매니폴드 가설)하고, 경사 하강법으로 모델 곡선을 이 데이터에 맞추면 모델이 데이터의 매니폴드를 대략적으로 근사하는 중간 지점을 찾을 수 있다.
  - 딥러닝 모델이 잠재 매니폴드를 학습하는 데 특히 잘 맞는 속성들이 있다
    - 모델의 매끄러움은(미분 가능성) 동일 속성을 가진 잠재 매니폴드를 근사하는 데에 도움이 된다
    - 딥려닝 모델은 훈련 데이터의 정보 형태를 반영하는 식으로 구조화되는데, 이는 자연적인 데이터가 구성되는 방식을 반영한 것이다
- 가장 중요한 훈련 데이터
  - 일반화의 능력은 모델의 속성보다는 데이터의 구조에 의한 결과이다. 즉, 데이터가 보간할 수 있는 매니폴드를 형성할 수 있어야 한다
    - 특성이 유익하고 잡음이 적을수록 입력 공간이 간단하고 구조적이기 때문에 일반화 성능이 좋다
    - 따라서 데이터 큐레이션(data curation)과 특성 공학(feature engineering)이 필수적이다
  - 모델이 곡선을 맞추는 것을 잘 수행하기 위해, 특히 결정 경계 근처에서, 입력 데이터 매니폴드 전체를 조밀하게 커버해야 한다. 충분히 조밀하게 샘플링하면 외부 지식 없이도 훈련 입력 사이를 보간하여 새로운 입력을 이해할 수 있게 된다.(일반화)
  - 결과적으로 딥러닝 모델을 향상시키는 가장 좋은 방법은 더 좋고, 더 많은 데이터에서 훈련하는 것이다
    - 만약 데이터를 더 수집하는 것이 불가능하다면, 제약을 추가할 수 있고 이를 **규제(regularizaion)**라고 부른다.



## 5.2 머신 러닝 모델 평가

### 5.2.1 훈련, 검증, 테스트 세트

- **훈련 세트**에서 모델을 훈련하고 검증 세트에서 모델을 평가한다. 그리고 모델이 완성된 후 **테스트 세트**를 통해 모델을 테스트한다.
- 검증 세트를 사용하는 이유
  - 검증 세트에서 평가하는 모델의 성능을 바탕으로 **하이퍼 파라미터 튜닝**을 수행한다
  - 그러나 튜닝도 학습의 일종으로 여러 번 반복할 경우 **정보 누설(information leak, 검증 데이터의 정보가 누설되는 것)**을 야기한다
- 모델은 테스트 세트에 대한 어떤 정보도 얻어서는 안 된다. 이는 일반화 성능을 왜곡시킨다.
- **단순 홀드아웃 검증(hold-out validation), K-겹 교차 검증(K-fold cross-validation), 셔플링(Shuffling)을 사용한 반복 K-겹 교차 검증(iterated K-fold cross-validation)**과 같은 기법을 사용할 수 있다.



#### 단순 홀드아웃 검증

- 데이터의 일정량을 테스트 세트로 떼어 놓고, 검증 세트도 따로 떼어 놓는다
- 주로 사이킷런의 train_test_split() 함수를 사용한다
- 이 방법은 단순하지만 데이터가 적을 때 검증 세트의 샘플 크기가 너무 작아 주어진 전체 데이터를 **통게적으로 대표하지 못할 수도 있다**는 단점이 있다

![holdout-validation](https://github.com/rurube/rurube.github.io/assets/81694385/4d3aca47-73dd-46a6-b3d6-048c6174fe14)



#### K-겹 교차 검증

- 데이터를 동일한 크기를 가진 K개의 분할로 나누고, 각 분할에 대해 남은 분할로 모델을 훈련하고 해당 분할에서 모델을 평가한다. 최종 점수는 이렇게 얻은 K개의 점수의 평균이다.
- 모델의 성능이 데이터 분할에 따라 편차가 클 때 도움이 된다

![kfold-crossvalidation](https://github.com/rurube/rurube.github.io/assets/81694385/1d3333a9-3379-4887-9f53-98ec7a9119ec)



#### 셔플링을 사용한 반복 K-겹 교차 검증

- 가용 데이터가 적고 정확하게 모델을 평가하고자 할 때 사용한다
- K-겹 교차 검증을 여러 번 적용하되, K개의 분할로 나누기 전에 매번 데이터를 무작위로 섞는다. 최종 점수는 모든 교차 검증을 실행해서 얻은 점수의 평균이다. 
- $반복 횟수\times K$개의 모델을 훈련하고 평가하므로 비용이 매우 많이 든다



### 5.2.2 상식 수준의 기준점 넘기

- 딥러닝 모델 훈련은 매니폴드 학습 과정을 관찰할 수 없기 때문에 작업을 시작하기 전 간단한 **기준점**을 정하는 것이 중요하다
- 이 기준점은 랜덤한 분류기의 성능이거나 머신 러닝을 사용하지 않고 생각할 수 있는 가장 간단한 방법이 될 수 있다



### 5.2.3 모델 평가에 대해 유념해야 할 점

- 대표성 있는 데이터
  - 훈련 세트와 테스트 세트가 주어진 데이터에 대한 **대표성**이 있어야 한다
  - 이를 위해 훈련 세트와 테스트 세트로 나누기 전에 데이터를 무작위로 섞는 것이 일반적이다
- 시간의 방향
  - 시계열 데이터의 경우에는 무작위로 섞어서는 안 된다
  - 테스트 세트의 데이터는 훈련 세트 데이터의 미래여야 한다
- 데이터 중복
  - 한 데이터셋에 어떤 데이터 포인트가 두 번 등장하면 데이터 세트를 나눈 후에 중복될 수 있다
  - 훈련 세트와 검증 세트가 중복되지 않는지 확인한다



## 5.3 훈련 성능 향상하기

​	최적적합 모델을 얻기 위해서는 과대적합으로 넘어가는 경계를 알아야 하므로, 초기 목표는 약간의 일반화 능력을 보이고 과대적합하는 모델을 얻는 것이다. 이후에 일반화 성능을 개선하는 데 초점을 맞춘다. 이 과정에서 발생할 수 있는 문제는 대표적으로 다음과 같다.

- 훈련이 되지 않음: 시간이 지나도 훈련 손실이 줄어들지 않는다
- 훈련은 잘 시작되었지만 모델이 의미 있는 일반화를 달성하지 못함: 상식 수준의 기준점을 넘어서지 못한다
- 시간이 지남에 따라 손실이 줄어들고 기준점을 넘어서지만 과대적합되지 않는다(여전히 과소적합이다)



### 5.3.1 경사 하강법의 핵심 파라미터 튜닝하기

- 훈련이 시작되지 않거나 너무 일찍 중단될 때 경사 하강법 과정을 점검한다
- 옵티마이저 선택, 모델 가중치의 초깃값 분포, 학습률, 배치 크기가 있다. 일반적으로 학습률과 배치 크기를 튜닝한다.
- 시도할 수 있는 방법은 다음과 같다
  - 학습률을 낮추거나 높인다. 너무 높은 학습률은 최적적합을 크게 뛰어넘는 업데이트가 일어날 수 있고, 너무 낮은 학습률은 훈련을 너무 느리게 만들 수 있다.
  - 배치 크기를 증가시킨다. 배치 샘플을 늘리면 유익하고 잡음이 적은(분산이 낮은) 그레이디언트가 만들어진다



### 5.3.2 구조에 대해 더 나은 가정하기

- 모델이 훈련되지만 일반화되지 않을 때, 이런 문제가 있을 수 있다
- 1. 입력 데이터에 타깃 예측을 위한 정보가 충분하지 않음
  2. 사용 모델의 종류가 문제에 적합하지 않음



### 5.3.3 모델 용량 늘리기

- 모델이 과대적합할 수 없는 것처럼 보인다면 모델의 **표현 능력(representational power)**이 부족한 것으로. 용량이 더 큰 모델을 사용한다
  - 층을 추가한다
  - (더 많은 가중치를 가지도록)층 크기를 늘린다
  - 현재 문제에 더 적합한 종류의 층을 사용한다



## 5.4 일반화 성능 향상하기

### 5.4.1 데이터셋 큐레이션

- 데이터가 충분한지 확인한다. 데이터가 많을수록 좋은 모델이 만들어진다.
- 레이블 할당 에러를 최소화한다. 입력을 시각화하여 이상치를 확인하고 레이블을 교정한다.
- 데이터를 정제하고 누락된 값을 처리한다
- 특성 선택을 수행한다



### 5.4.2 특성 공학

- 데이터와 머신 러닝 알고리즘에 관한 지식을 사용하는 단계
- 모델에 데이터를 주입하기 전 하드코딩된 변환을 적용하여 알고리즘이 더 잘 수행되도록 함
- 특성을 더 간단한 방식으로 표현하여 문제를 쉽게 만든다. 즉, 잠재 매니폴드를 더 매끄럽고, 간단하고, 구조적으로 만든다.
- 딥러닝의 신경망은 자동으로 원본 데이터에서 유용한 특성을 추출할 수 있기 때문에 대부분 특성 공학이 필요하지 않지만, 다음과 같은 이유로 신경쓸 필요가 있다
  - 좋은 특성은 적은 자원을 사용한다
  - 좋은 특성은 더 적은 데이터로 문제를 풀 수 있다



### 5.4.3 조기 종료 사용하기

- 딥러닝은 파라미터가 많은 모델을 사용하므로, 잠재 매니폴드를 학습하기 위해 필요한 최소치보다 훨씬 많은 자유도를 가진다
- 모델을 끝까지 훈련하면 일반화가 되지 않으므로 항상 훈련 손실이 최솟값에 도달하기 전에 훈련을 중단한다
- 직접 모델을 훈련하여 에포크 횟수를 찾으면 중복 작업이 되고 종종 많은 비용이 들게 된다. 따라서 케라스에서는 일반적으로 **EarlyStopping callback**을 사용한다. 검증 지표가 더이상 향상되지 않으면 훈련을 중지하고 최상의 검증 점수를 낸 모델을 남길 수 있다.



### 5.4.4 모델 규제하기

- **규제(regularization)**기법은 훈련 데이터에 완벽하게 맞추려는 모델의 능력을 방해하여 모델의 검증 점수를 향상시킨다
- 모델이 훈련 세트에 덜 특화되고 데이터의 잠재 매니폴드를 조금 더 가깝게 근사함으로써 일반화 능력을 높일 수 있다
- 모델 규제는 항상 정확한 평가 절차를 따라야 하며, 측정이 가능한 경우에만 일반화를 달성할 수 있다
- 용량이 큰 모델일수록 더 빠르게 훈련 데이터를 모델링할 수 있지만 **과대적합에 민감해진다**
- 가중치 규제 추가
  - 오캄의 면도날(Occam's razor) 이론: 어떤 것에 대한 두 가지 설명이 있다면 더 적은 가정이 필요한 간단한 설명이 옳을 것이라는 이론
  - 간단한 모델이 복잡한 모델보다 과대적합될 가능성이 낮다
    - 여기서 간단한 모델은 파라미터 값 분포의 엔트로피가 작은 모델이다
  - 따라서 과대적합을 완화하기 위해 모델의 복잡도에 제한을 두어 가중치가 작은 값을 가지도록 강제해 가중치 값의 분포를 더 균일하게 만드는데, 이를 **가중치 규제(weight regularization)**라고 하며, 모델의 손실 함수에 큰 가중치에 연관된 비용을 추가한다.
    1. L1 규제: 가중치에 절댓값에 비례하는 비용이 추가된다(가중치의 L1 노름)
    2. L2 규제: 가중치의 제곱에 비레하는 비용이 추가된다(가중치의 L2 노름<sup>[[1]](#footnote_1)</sup>). L2 규제는 가중치 감쇠라고도 부른다.
  - 케라스에서는 가중치 규제 객체를 층의 키워드 매개변수로 전달하여 가중치 규제를 추가할 수 있다
  - 모델이 동일한 파라미터 개수를 가지고 있어도 L2 규제를 사용한 모델이 기본 모델보다 과대적합에 더 잘 견딜 수 있다
  - 대규모 딥러닝 모델은 가중치 값을 제약하는 것이 큰 영향을 미치지 않기 때문에 가중치 규제는 일반적으로 작은 딥러닝 모델에서 사용한다
- 드롭아웃 추가
  - 모델 층에 드롭아웃을 적용하면 훈련하는 동안 무작위로 층의 출력 특성을 일부 제외시킨다(0으로 만든다)
  - 드롭아웃 비율은 0이 될 특성의 비율로, 보통 0.2에서 0.5 사이로 지정된다
  - 테스트 단계에서는 드롭아웃을 적용하지 않으며, 대신 층의 출력 드롭아웃 비율에 비례하여 줄인다
  - 드롭아웃으로 뉴런의 '부정한 협업'을 방지해 과대적합을 감소시킨다 -> 우연한 패턴을 기억하지 않게 한다







<a name="footnote_1">[1]</a>: L2 노름은 유클리드 노름이라고도 부른다. 가중치의 파라미터를 모두 제곱하여 더한 후 이 값의 제곱근을 구한다. L2 규제에서 추가되는 비용은 정확히는 L2 노름의 제곱이지만, 그냥 L2 노름이라고 얘기하는 경우가 많다.

